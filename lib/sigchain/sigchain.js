// Generated by IcedCoffeeScript 1.7.1-g
(function() {
  var ChainLink, E, ParsedKeys, SigChain, a_json_parse, athrow, iced, ie, kbpgp, make_esc, proofs, __iced_k, __iced_k_noop, _ref;

  iced = require('iced-runtime');
  __iced_k = __iced_k_noop = function() {};

  _ref = require('iced-utils').util, athrow = _ref.athrow, a_json_parse = _ref.a_json_parse;

  make_esc = require('iced-error').make_esc;

  kbpgp = require('kbpgp');

  proofs = require('keybase-proofs');

  ie = require('iced-error');

  exports.ParsedKeys = ParsedKeys = (function() {
    ParsedKeys.parse = function(_arg, cb) {
      var bundle, bundles_list, esc, fingerprint, fingerprint_str, key_manager, key_managers, kid, kid_str, kid_to_pgp, kids_in_order, parsed_keys, pgp_to_kid, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      bundles_list = _arg.bundles_list;
      esc = make_esc(cb, "ParsedKeys.parse");
      key_managers = {};
      pgp_to_kid = {};
      kid_to_pgp = {};
      kids_in_order = [];
      (function(_this) {
        return (function(__iced_k) {
          var _i, _len, _ref1, _results, _while;
          _ref1 = bundles_list;
          _len = _ref1.length;
          _i = 0;
          _results = [];
          _while = function(__iced_k) {
            var _break, _continue, _next;
            _break = function() {
              return __iced_k(_results);
            };
            _continue = function() {
              return iced.trampoline(function() {
                ++_i;
                return _while(__iced_k);
              });
            };
            _next = function(__iced_next_arg) {
              _results.push(__iced_next_arg);
              return _continue();
            };
            if (!(_i < _len)) {
              return _break();
            } else {
              bundle = _ref1[_i];
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                  funcname: "ParsedKeys.parse"
                });
                kbpgp.ukm.import_armored_public({
                  armored: bundle
                }, esc(__iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return key_manager = arguments[0];
                    };
                  })(),
                  lineno: 19
                })));
                __iced_deferrals._fulfill();
              })(function() {
                kid = key_manager.get_ekid();
                kid_str = kid.toString("hex");
                key_managers[kid_str] = key_manager;
                kids_in_order.push(kid_str);
                fingerprint = key_manager.get_pgp_fingerprint();
                return _next(fingerprint != null ? (fingerprint_str = fingerprint.toString("hex"), key_managers[fingerprint.toString("hex")] = key_manager, pgp_to_kid[fingerprint_str] = kid_str, kid_to_pgp[kid_str] = fingerprint_str) : void 0);
              });
            }
          };
          _while(__iced_k);
        });
      })(this)((function(_this) {
        return function() {
          parsed_keys = new ParsedKeys({
            key_managers: key_managers,
            pgp_to_kid: pgp_to_kid,
            kid_to_pgp: kid_to_pgp,
            kids_in_order: kids_in_order
          });
          return cb(null, parsed_keys);
        };
      })(this));
    };

    function ParsedKeys(_arg) {
      this.key_managers = _arg.key_managers, this.pgp_to_kid = _arg.pgp_to_kid, this.kid_to_pgp = _arg.kid_to_pgp, this.kids_in_order = _arg.kids_in_order;
    }

    return ParsedKeys;

  })();

  ChainLink = (function() {
    ChainLink.parse = function(_arg, cb) {
      var ctime_seconds, err, esc, key_manager, kid, parsed_keys, payload, payload_buffer, payload_hash, payload_json, sig_blob, sig_buffer, sig_id, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      sig_blob = _arg.sig_blob, parsed_keys = _arg.parsed_keys;
      esc = make_esc(cb, "ChainLink.parse");
      sig_buffer = new Buffer(sig_blob.sig, "base64");
      sig_id = kbpgp.hash.SHA256(sig_buffer).toString("hex");
      kid = sig_blob.kid;
      ctime_seconds = sig_blob.ctime;
      key_manager = parsed_keys.key_managers[kid];
      (function(_this) {
        return (function(__iced_k) {
          if (key_manager == null) {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                funcname: "ChainLink.parse"
              });
              athrow(new E.NonexistentKidError("link signed by nonexistent kid " + kid), esc(__iced_deferrals.defer({
                lineno: 53
              })));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
              funcname: "ChainLink.parse"
            });
            key_manager.make_sig_eng().unbox(sig_blob.sig, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  err = arguments[0];
                  return payload_buffer = arguments[1];
                };
              })(),
              lineno: 56
            }), {
              now: ctime_seconds
            });
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              if (typeof err !== "undefined" && err !== null) {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                    funcname: "ChainLink.parse"
                  });
                  athrow(new E.VerifyFailedError(err.message), esc(__iced_deferrals.defer({
                    lineno: 59
                  })));
                  __iced_deferrals._fulfill();
                })(__iced_k);
              } else {
                return __iced_k();
              }
            })(function() {
              payload_hash = kbpgp.hash.SHA256(payload_buffer).toString("hex");
              payload_json = payload_buffer.toString('utf8');
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                  funcname: "ChainLink.parse"
                });
                a_json_parse(payload_json, esc(__iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return payload = arguments[0];
                    };
                  })(),
                  lineno: 64
                })));
                __iced_deferrals._fulfill();
              })(function() {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                    funcname: "ChainLink.parse"
                  });
                  _this._check_payload_against_blob({
                    signing_kid: kid,
                    signing_ctime: ctime_seconds,
                    payload: payload,
                    parsed_keys: parsed_keys
                  }, esc(__iced_deferrals.defer({
                    lineno: 67
                  })));
                  __iced_deferrals._fulfill();
                })(function() {
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                      funcname: "ChainLink.parse"
                    });
                    _this._check_reverse_signatures({
                      payload: payload,
                      parsed_keys: parsed_keys
                    }, esc(__iced_deferrals.defer({
                      lineno: 69
                    })));
                    __iced_deferrals._fulfill();
                  })(function() {
                    return cb(null, new ChainLink({
                      kid: kid,
                      sig_id: sig_id,
                      payload: payload,
                      payload_hash: payload_hash
                    }));
                  });
                });
              });
            });
          });
        };
      })(this));
    };

    ChainLink._check_payload_against_blob = function(_arg, cb) {
      var err, parsed_keys, payload, payload_ctime, payload_fingerprint, payload_kid, signing_ctime, signing_kid;
      signing_kid = _arg.signing_kid, signing_ctime = _arg.signing_ctime, payload = _arg.payload, parsed_keys = _arg.parsed_keys;
      payload_kid = payload.body.key.kid;
      payload_fingerprint = payload.body.key.fingerprint;
      payload_ctime = payload.ctime;
      err = null;
      if ((payload_kid != null) && payload_kid !== signing_kid) {
        err = new E.KidMismatchError("signing kid (" + signing_kid + ") and payload kid (" + payload_kid + ") mismatch");
      } else if ((payload_fingerprint != null) && payload_fingerprint !== parsed_keys.kid_to_pgp[signing_kid]) {
        err = new E.FingerprintMismatchError("signing kid (" + signing_kid + ") and payload fingerprint (" + payload_fingerprint + ") mismatch");
      } else if (payload_ctime !== signing_ctime) {
        err = new E.CtimeMismatchError("payload ctime (" + payload_ctime + ") doesn't match signing ctime (" + signing_ctime + ")");
      }
      return cb(err);
    };

    ChainLink._check_reverse_signatures = function(_arg, cb) {
      var err, esc, key_manager, kid, parsed_keys, payload, sibkey_proof, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      payload = _arg.payload, parsed_keys = _arg.parsed_keys;
      esc = make_esc(cb, "ChainLink._check_reverse_signatures");
      if (payload.body.sibkey == null) {
        cb(null);
        return;
      }
      kid = payload.body.sibkey.kid;
      key_manager = parsed_keys.key_managers[kid];
      (function(_this) {
        return (function(__iced_k) {
          if (key_manager == null) {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                funcname: "ChainLink._check_reverse_signatures"
              });
              athrow(new E.NonexistentKidError("link reverse-signed by nonexistent kid " + kid), esc(__iced_deferrals.defer({
                lineno: 94
              })));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        });
      })(this)((function(_this) {
        return function() {
          sibkey_proof = new proofs.Sibkey({});
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
              funcname: "ChainLink._check_reverse_signatures"
            });
            sibkey_proof.reverse_sig_check({
              json: payload,
              subkm: key_manager
            }, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return err = arguments[0];
                };
              })(),
              lineno: 96
            }));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              if (typeof err !== "undefined" && err !== null) {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                    funcname: "ChainLink._check_reverse_signatures"
                  });
                  athrow(new E.VerifyFailedError(err.message), esc(__iced_deferrals.defer({
                    lineno: 98
                  })));
                  __iced_deferrals._fulfill();
                })(__iced_k);
              } else {
                return __iced_k();
              }
            })(function() {
              return cb(null);
            });
          });
        };
      })(this));
    };

    function ChainLink(_arg) {
      var _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      this.kid = _arg.kid, this.sig_id = _arg.sig_id, this.payload = _arg.payload, this.payload_hash = _arg.payload_hash;
      this.uid = this.payload.body.key.uid;
      this.username = this.payload.body.key.username;
      this.seqno = this.payload.seqno;
      this.prev = this.payload.prev;
      this.fingerprint = this.payload.body.key.fingerprint;
      this.eldest_kid = this.payload.body.key.eldest_kid || this.kid;
      this.ctime_seconds = this.payload.body.ctime;
      this.etime_seconds = this.ctime_seconds + this.payload.body.expire_in;
      this.sibkey_delegation = (_ref1 = this.payload.body.sibkey) != null ? _ref1.kid : void 0;
      this.subkey_delegation = (_ref2 = this.payload.body.subkey) != null ? _ref2.kid : void 0;
      this.key_revocations = [];
      if (((_ref3 = this.payload.body.revoke) != null ? _ref3.kids : void 0) != null) {
        this.key_revocations = this.payload.body.revoke.kids;
      }
      if (((_ref4 = this.payload.body.revoke) != null ? _ref4.kid : void 0) != null) {
        this.key_revocations.push(this.payload.body.revoke.kid);
      }
      this.sig_revocations = [];
      if (((_ref5 = this.payload.body.revoke) != null ? _ref5.sig_ids : void 0) != null) {
        this.sig_revocations = this.payload.body.revoke.sig_ids;
      }
      if (((_ref6 = this.payload.body.revoke) != null ? _ref6.sig_id : void 0) != null) {
        this.sig_revocations.push(this.payload.body.revoke.sig_id);
      }
    }

    return ChainLink;

  })();

  exports.SigChain = SigChain = (function() {
    SigChain.replay = function(_arg, cb) {
      var eldest_kid, esc, parsed_keys, sig_blob, sig_blobs, sigchain, uid, username, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      sig_blobs = _arg.sig_blobs, parsed_keys = _arg.parsed_keys, uid = _arg.uid, username = _arg.username, eldest_kid = _arg.eldest_kid;
      esc = make_esc(cb, "SigChain.replay");
      (function(_this) {
        return (function(__iced_k) {
          if (eldest_kid == null) {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                funcname: "SigChain.replay"
              });
              athrow(new Error("eldest_kid parameter is required"), esc(__iced_deferrals.defer({
                lineno: 135
              })));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        });
      })(this)((function(_this) {
        return function() {
          sigchain = new SigChain({
            uid: uid,
            username: username,
            eldest_kid: eldest_kid
          });
          (function(__iced_k) {
            var _i, _len, _ref1, _results, _while;
            _ref1 = sig_blobs;
            _len = _ref1.length;
            _i = 0;
            _results = [];
            _while = function(__iced_k) {
              var _break, _continue, _next;
              _break = function() {
                return __iced_k(_results);
              };
              _continue = function() {
                return iced.trampoline(function() {
                  ++_i;
                  return _while(__iced_k);
                });
              };
              _next = function(__iced_next_arg) {
                _results.push(__iced_next_arg);
                return _continue();
              };
              if (!(_i < _len)) {
                return _break();
              } else {
                sig_blob = _ref1[_i];
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                    funcname: "SigChain.replay"
                  });
                  sigchain._add_new_link({
                    sig_blob: sig_blob,
                    parsed_keys: parsed_keys
                  }, esc(__iced_deferrals.defer({
                    lineno: 138
                  })));
                  __iced_deferrals._fulfill();
                })(_next);
              }
            };
            _while(__iced_k);
          })(function() {
            return cb(null, sigchain);
          });
        };
      })(this));
    };

    function SigChain(_arg) {
      var eldest_kid, uid, username;
      uid = _arg.uid, username = _arg.username, eldest_kid = _arg.eldest_kid;
      this._uid = uid;
      this._username = username;
      this._eldest_kid = eldest_kid;
      this._links = [];
      this._unrevoked_links = {};
      this._sibkeys_to_etime_seconds = {};
      this._valid_sibkeys = {};
      this._valid_sibkeys[eldest_kid] = true;
    }

    SigChain.prototype.get_links = function() {
      var link;
      return (function() {
        var _i, _len, _ref1, _results;
        _ref1 = this._links;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          link = _ref1[_i];
          if (link.sig_id in this._unrevoked_links) {
            _results.push(link);
          }
        }
        return _results;
      }).call(this);
    };

    SigChain.prototype.get_sibkeys = function() {
      var kid;
      return (function() {
        var _results;
        _results = [];
        for (kid in this._valid_sibkeys) {
          _results.push(kid);
        }
        return _results;
      }).call(this);
    };

    SigChain.prototype._add_new_link = function(_arg, cb) {
      var esc, link, parsed_keys, sig_blob, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      sig_blob = _arg.sig_blob, parsed_keys = _arg.parsed_keys;
      esc = make_esc(cb, "SigChain._add_new_link");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
            funcname: "SigChain._add_new_link"
          });
          ChainLink.parse({
            sig_blob: sig_blob,
            parsed_keys: parsed_keys
          }, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return link = arguments[0];
              };
            })(),
            lineno: 167
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          if (link.eldest_kid !== _this._eldest_kid) {
            cb();
            return;
          }
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
              funcname: "SigChain._add_new_link"
            });
            _this._check_key_is_valid({
              link: link
            }, esc(__iced_deferrals.defer({
              lineno: 178
            })));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                funcname: "SigChain._add_new_link"
              });
              _this._check_link_belongs_here({
                link: link
              }, esc(__iced_deferrals.defer({
                lineno: 181
              })));
              __iced_deferrals._fulfill();
            })(function() {
              _this._links.push(link);
              _this._unrevoked_links[link.sig_id] = link;
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                  funcname: "SigChain._add_new_link"
                });
                _this._delegate_keys({
                  link: link
                }, esc(__iced_deferrals.defer({
                  lineno: 188
                })));
                __iced_deferrals._fulfill();
              })(function() {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/home/jacko/libkeybase-js/src/sigchain/sigchain.iced",
                    funcname: "SigChain._add_new_link"
                  });
                  _this._revoke_keys_and_sigs({
                    link: link
                  }, esc(__iced_deferrals.defer({
                    lineno: 190
                  })));
                  __iced_deferrals._fulfill();
                })(function() {
                  return cb(null);
                });
              });
            });
          });
        };
      })(this));
    };

    SigChain.prototype._check_key_is_valid = function(_arg, cb) {
      var err, link;
      link = _arg.link;
      err = null;
      if (!(link.kid in this._valid_sibkeys)) {
        err = new E.InvalidSibkeyError("not a valid sibkey: " + link.kid + " valid sibkeys: " + (JSON.stringify(this._valid_sibkeys)));
      } else if (link.ctime_seconds < this._sibkeys_to_etime_seconds[link.kid]) {
        err = new E.ExpiredSibkeyError("expired sibkey: " + link.kid);
      }
      return cb(err);
    };

    SigChain.prototype._check_link_belongs_here = function(_arg, cb) {
      var err, last_link, link;
      link = _arg.link;
      last_link = this._links[this._links.length - 1];
      err = null;
      if (link.uid !== this._uid) {
        err = new E.WrongUIDError("link doesn't refer to the right uid\nexpected: " + link.uid + "\n     got: " + this._uid);
      } else if (link.username !== this._username) {
        err = new E.WrongUsernameError("link doesn't refer to the right username\nexpected: " + link.username + "\n     got: " + this._username);
      } else if ((last_link != null) && link.seqno !== last_link.seqno + 1) {
        err = new E.WrongSeqnoError("link sequence number is wrong\nexpected: " + (last_link.seqno + 1) + "\n     got: " + link.seqno);
      } else if ((last_link != null) && link.prev !== last_link.payload_hash) {
        err = new E.WrongPrevError("previous payload hash doesn't match,\nexpected: " + last_link.payload_hash + "\n     got: " + link.prev);
      }
      return cb(err);
    };

    SigChain.prototype._delegate_keys = function(_arg, cb) {
      var link;
      link = _arg.link;
      if (link.sibkey_delegation != null) {
        this._valid_sibkeys[link.sibkey_delegation] = true;
        this._sibkeys_to_etime_seconds[link.sibkey_delegation] = link.etime;
      }
      if (link.kid === this._eldest_kid && !(this._eldest_kid in this._sibkeys_to_etime_seconds)) {
        this._sibkeys_to_etime_seconds[this._eldest_kid] = link.etime;
      }
      return cb();
    };

    SigChain.prototype._revoke_keys_and_sigs = function(_arg, cb) {
      var kid, link, revoked_kid, revoked_link, sig_id, _i, _j, _len, _len1, _ref1, _ref2;
      link = _arg.link;
      _ref1 = link.key_revocations;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        kid = _ref1[_i];
        if (kid in this._valid_sibkeys) {
          delete this._valid_sibkeys[kid];
        }
      }
      _ref2 = link.sig_revocations;
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        sig_id = _ref2[_j];
        if (sig_id in this._unrevoked_links) {
          revoked_link = this._unrevoked_links[sig_id];
          delete this._unrevoked_links[sig_id];
          revoked_kid = revoked_link.sibkey_delegation;
          if ((revoked_kid != null) && revoked_kid in this._valid_sibkeys) {
            delete this._valid_sibkeys[revoked_kid];
          }
        }
      }
      return cb();
    };

    return SigChain;

  })();

  exports.E = E = ie.make_errors({
    "NONEXISTENT_KID": "",
    "VERIFY_FAILED": "",
    "KID_MISMATCH": "",
    "FINGERPRINT_MISMATCH": "",
    "CTIME_MISMATCH": "",
    "INVALID_SIBKEY": "",
    "EXPIRED_SIBKEY": "",
    "WRONG_UID": "",
    "WRONG_USERNAME": "",
    "WRONG_SEQNO": "",
    "WRONG_PREV": ""
  });

}).call(this);
